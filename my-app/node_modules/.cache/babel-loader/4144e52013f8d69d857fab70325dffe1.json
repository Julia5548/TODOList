{"ast":null,"code":"import { getCookie } from \"./cookie\";\nimport { baseUrl } from \"./baseUrlRequest\";\nconst csrftoken = getCookie('csrftoken');\n\nconst dataFetch = (url, data) => {\n  return new Request(url, {\n    mode: 'cors',\n    headers: {\n      'X-CSRFToken': csrftoken\n    },\n    method: 'POST',\n    body: JSON.stringify(data)\n  });\n};\n\nexport async function fetchLoginUser(login_user) {\n  // console.log(dataFetch)\n  const response = fetch(dataFetch('http://127.0.0.1:8000/api/v1/token/auth/', login_user));\n  const data = response.then(response => response.json()).catch(error => {\n    console.log('ERROR_FETCH: ', error);\n  });\n  return await data;\n}\n\nconst prepareBodyRequest = payload => {\n  return JSON.stringify(payload);\n};\n\nconst prepareHeadersRequest = token => {\n  let headers;\n  headers = {\n    'Content-type': 'application/json'\n  };\n\n  if (token) {\n    headers = { ...headers,\n      Authorization: `JWT ${token}`\n    };\n  }\n\n  return headers;\n};\n\nconst getResponseBody = async response => {\n  let data;\n\n  if (response.status !== 204 && response.status < 300) {\n    data = await response.json();\n  }\n\n  return {\n    data,\n    status: response.status,\n    statusText: response.statusText\n  };\n};\n\nconst request = async (url, // data: RequestData<P>,\ntoken) => {\n  if (data.payload) {\n    data.body = prepareBodyRequest(data.payload);\n  }\n\n  data.mode = 'cors';\n  data.headers = prepareHeadersRequest(token);\n  const requestUrl = baseUrl + url;\n  let response;\n\n  try {\n    response = await fetch(requestUrl, data);\n  } catch (error) {\n    console.log(\"Что-то не так с сетью\");\n  }\n\n  const responseBody = await getResponseBody(response);\n\n  if (responseBody.status < 200 || responseBody.status >= 300) {\n    console.log(responseBody.status, responseBody.statusText);\n  }\n\n  return response.ok ? {\n    response: responseBody\n  } : {\n    error: responseBody.data\n  };\n};\n\nexport const signIn = payload => request('token/auth/', {\n  method: 'POST',\n  payload\n});\nexport const getTodos = () => request('detail/todos/', {\n  method: 'POST',\n  user\n});","map":{"version":3,"sources":["/home/julia/ToDoList/my-app/src/services/index.tsx"],"names":["getCookie","baseUrl","csrftoken","dataFetch","url","data","Request","mode","headers","method","body","JSON","stringify","fetchLoginUser","login_user","response","fetch","then","json","catch","error","console","log","prepareBodyRequest","payload","prepareHeadersRequest","token","Authorization","getResponseBody","status","statusText","request","requestUrl","responseBody","ok","signIn","getTodos","user"],"mappings":"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","sourcesContent":["import { getCookie } from \"./cookie\";\nimport { IUser } from \"../interfaces/IUser\";\nimport { baseUrl } from \"./baseUrlRequest\";\nimport { ITodoList } from \"../interfaces/ITodoList\";\n\n\nconst csrftoken = getCookie('csrftoken');\n\nconst dataFetch = (url : string, data) => {\n    return (\n        new Request(url,{\n            mode : 'cors',\n                headers: {\n                   \n                    'X-CSRFToken' : csrftoken!,\n                },\n            method : 'POST',\n            body : JSON.stringify(data)\n        })\n    );\n}\n\nexport async function fetchLoginUser(login_user){\n\n    // console.log(dataFetch)\n    const response = fetch(dataFetch('http://127.0.0.1:8000/api/v1/token/auth/', login_user))\n\n    const data = response.then(response =>\n        response.json()\n    ).catch(error => {\n        console.log('ERROR_FETCH: ', error);\n    });\n\n    return await data;\n}\nexport type Empty = {}\ntype Payload = Record<string, any>;\ntype Response = Record<string, any>;\n\ninterface RequestData<P extends Payload> extends RequestInit{\n    payload? : P;\n}\n\ninterface ResponseBody<R extends Response > {\n    data?: R;\n    status: number;\n    statusText: string;\n}\n  \ninterface ResponseData<R extends Response >{ \n    response?: ResponseBody<R>;\n    error?: any;\n}\n\n\nconst prepareBodyRequest = <T extends Payload>(payload: T) : string => {\n    return JSON.stringify(payload);\n}\n\nconst prepareHeadersRequest = (token?: string) : Record<string, string> => {\n\n    let headers : Record<string, string>;\n    headers = {\n        'Content-type' : 'application/json',\n    };\n\n    if(token) {\n        headers = {\n            ...headers,\n            Authorization : `JWT ${token}`\n        };\n    }\n    return headers;\n}\n\nconst getResponseBody = async <R extends Response>(response : Response) : Promise<ResponseBody<R>> => {\n    let data;\n    if(response.status !== 204 && response.status < 300 ){\n        data = await response.json();\n    }\n    return {\n        data, \n        status : response.status,\n        statusText : response.statusText,\n    };\n}\n\nconst request = async <P extends Payload, R extends Response>(\n    url : string,\n    // data: RequestData<P>,\n    token? : string,\n) : Promise<ResponseData<R>> => {\n\n    if(data.payload){\n        data.body = prepareBodyRequest<Payload>(data.payload);\n    }\n    \n    data.mode = 'cors';\n    data.headers = prepareHeadersRequest(token);\n    \n    const requestUrl = baseUrl + url;\n    let response;\n    \n    try{\n        response = await fetch(requestUrl, data);\n    }catch(error){\n        console.log(\"Что-то не так с сетью\");\n    }\n\n    const responseBody = await getResponseBody<R>(response);\n    \n    if(responseBody.status < 200 || responseBody.status >= 300 ){\n        console.log(responseBody.status, responseBody.statusText);\n    }\n\n    return response.ok \n    ? { response : responseBody}\n    : {error : responseBody.data};\n}\n\ninterface TokenResponse{\n    token : string;\n}\nexport const signIn =(payload : IUser) => request<IUser, TokenResponse >(\n    'token/auth/', {method : 'POST',  payload},\n);\n\nexport const getTodos = () => request<ITodoList, TokenResponse >(\n    'detail/todos/', {method : 'POST',  user},\n);"]},"metadata":{},"sourceType":"module"}